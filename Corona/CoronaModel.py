import StateModeling as stm
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

def CoronaModel(AllMeasured):
    M = stm.Model(maxAxes=4)
    M.addAxis("Gender", entries=len(AllMeasured['Gender']), labels=AllMeasured['Gender'])
    M.addAxis("Age", entries=len(AllMeasured['Ages']), labels=AllMeasured['Ages'])
    M.addAxis("District", entries=len(AllMeasured['LKs']), labels=AllMeasured['LKs'])
    M.addAxis("Disease Progression", entries=28, queue=True)

    # modeling infection:
    r0Init = 9.2 * np.ones(M.Axes['Age'].shape, stm.CalcFloatStr)
    it0Init = 3.5 # day in 'Disease Progression' of most probably infecting someone else
    sigmaI = 3.0 # spread in 'Disease Progression' of most probably infecting someone else

    # model the general awareness effect:
    aT0Init = AllMeasured['Dates'].index('05.03.2020')+0.0 # Awareness effect mean day of decreasing R
    aBaseInit = 0.14 # relative drop down to this value of infectiveness cause by awareness
    aSigma = 4.0 # spread for sigmoidal awareness curve

    # modelling the german soft-lock:
    qInit = 0.0052  # lockdown quarantine percentage (has to be multiplied roughly by 3)
    sigmaQ = 1.5 # spread for soft-lock
    LockDown = AllMeasured['Dates'].index('23.03.2020')+0.0  # Time of German lockdown, Quelle: RKI bulletin
    unlock = AllMeasured['Dates'].index('20.04.2020')+0.0  # This is when retail changed! 79
    relUnlock = 0.8
    dInit = 0.13 # detection rate for quarantine from population

    # first infection
    # T0Init = AllMeasured['Dates'].index('03.03.2020')+0.2   # day of first infection in the district
    T0Init = AllMeasured['Dates'].index('21.02.2020')+0.2   # day of first infection in the district
    I0Init = 5e-9 # Amount of first infection  (1.0 would be 5e-7 )

    # hospitalization:
    hInit = 0.06 # rate of hospitalization
    AgeBorderInit = 2.3 # age limit (in bins) for probable hospitalization
    AgeSigmaInit = 0.5 # age spead (in bins) for probable hospitalization
    ht0Init = 5.5 # day of 'Disease Progression' when hospitalization is most probable
    # intensive care
    hic = 0.05  # rate to be transferred to ICUs, should really be age dependent
    rdInit = 0.05  # rate to die, should really be age dependent

    TPop = np.sum(AllMeasured['Population'])
    # susceptible
    M.newState(name='S', axesInit={"Age": 1.0, "District": AllMeasured['Population']/TPop, "Gender": 1.0})
    # I0 = M.newVariables({'I0': 0.000055 * InitPopulM}, forcePos=False)  # a district dependent variable of initially infected
    # assume 4.0 infected at time 0
    #  (2.0/323299.0) * InitPopul
    I0 = M.newVariables({'I0': I0Init}, forcePos=False)  # a global variable of initial infection probability
    # InitProgression = lambda: I0 * M.Axes['Disease Progression'].initDelta()  # variables to fit have to always be packed in lambda functions!
    # M.newState(name='I', axesInit={"Disease Progression": InitProgression, "District": None, "Age": None, "Gender": None})
    # infected (not detected):
    M.newState(name='I', axesInit={"Disease Progression": 0, "District": 0, "Age": 0, "Gender": 0})
    # cured (not detected):
    M.newState(name='C', axesInit={"District": 0, "Age": 0, "Gender": 0})
    T0 = M.newVariables({"T0": T0Init * np.ones(M.Axes['District'].shape, stm.CalcFloatStr)}, forcePos=False)  # time at which a delta is injected into the start of the progression axis
    # the initial infection is generated by "injecting" a Gaussian (to be differentiable)
    M.addRate('S', 'I', lambda t: I0() * M.initGaussianT0(T0(), t), queueDst='Disease Progression', hasTime=True)

    # Age-dependent base rate of infection
    aT0 = M.newVariables({'aT0': aT0Init}, forcePos=True)  # awarenessTime
    aBase = M.newVariables({'aBase': aBaseInit}, forcePos=True)  # residual relative rate after awareness effect
    awareness = lambda t: M.initSigmoidDropT0(aT0(), t, aSigma, aBase())  # 40% drop in infection rate

    it0 = M.newVariables({'it0': it0Init}, forcePos=True) # day of most probably infecting someone else
    infectiveness = M.Axes['Disease Progression'].initGaussian(it0(), sigmaI)

    # InitPupulDistrictOnly = np.sum(InitPopul,(-1,-2), keepdims=True)
    r0 = M.newVariables({'r0': r0Init}, forcePos=True)
    RelPopulation = AllMeasured['Population'] / TPop
    M.addRate(('S', 'I'), 'I', lambda t: (r0()* awareness(t) * infectiveness) / RelPopulation,
              queueDst="Disease Progression", hasTime=True, hoSumDims=['Age', 'Gender'])  # S ==> I[0]
    M.addRate('I', 'C', 1.0, queueSrc="Disease Progression")  # I --> C when through the queue

    # --- The (undetected) quarantine process:
    # susceptible, quarantined
    M.newState(name='Sq', axesInit={"District": 0, "Age": 0, "Gender": 0})
    # infected, quarantined
    M.newState(name='Iq', axesInit={"Disease Progression": 0, "District": 0, "Age": 0, "Gender": 0})
    q = M.newVariables({"q": qInit * np.ones(M.Axes['District'].shape, stm.CalcFloatStr)}, forcePos=True)  # quarantine ratio (of all ppl.) modeled as a Gaussian (see below)
    lockDownFct = lambda t: q() * M.initGaussianT0(LockDown, t, sigmaQ)
    M.addRate('S', 'Sq', lockDownFct, hasTime=True)
    unlockFct = lambda t: relUnlock * M.initDeltaT0(unlock, t, sigmaQ)
    M.addRate('I', 'Iq', lockDownFct, hasTime=True)  # S -q-> Sq
    M.addRate('Sq', 'S', unlockFct, hasTime=True)  # Sq --> S
    M.addRate('Iq', 'I', unlockFct, hasTime=True)  # Iq --> I
    M.addRate('Iq', 'C', 1.0, queueSrc="Disease Progression")  # Iq --> C when through the infection queue. Quarantine does not matter any more
    # ---------- detecting some of the infected:
    # detected quarantine state:
    M.newState(name='Q', axesInit={"Disease Progression": 0, "District": 0, "Age": 0, "Gender": 0})
    d = M.newVariables({'d': dInit}, forcePos=True)  # detection rate
    M.addRate('I', 'Q', d, resultTransfer=('cases', 'Disease Progression'))  # S -q-> Sq
    M.addRate('Iq', 'Q', d, resultTransfer=('cases', 'Disease Progression'))  # detection by testing inside the quarantine
    # ---- hospitalizing the ill
    # hospitalized state:
    M.newState(name='H', axesInit={"Disease Progression": 0, "District": 0, "Age": 0, "Gender": 0})
    ht0 = M.newVariables({'ht0': ht0Init}, forcePos=False)  # most probable time of hospitalization

    h = M.newVariables({'h': hInit})  # rate of hospitalization, should be age dependent
    # influx = M.newVariables({'influx': 0.0001})  # a district dependent variable of initially infected
    # infectionRate = lambda I: (I + influx) * M.Var['r0']
    AgeBorder = M.newVariables({'AgeBorder': AgeBorderInit}, forcePos=False, normalize=None)  # rate of hospitalization, should be age dependent
    AgeSigma = M.newVariables({'AgeSigma': AgeSigmaInit}, forcePos=False, normalize=None)  # rate of hospitalization, should be age dependent
    hospitalization = lambda: h() * M.Axes['Disease Progression'].initGaussian(ht0(), 3.0) * \
                              M.Axes['Age'].initSigmoid(AgeBorder(), AgeSigma())
    M.addRate('I', 'H', hospitalization, resultTransfer=(('cases', 'Disease Progression'),('hospitalization', 'Disease Progression')))  # I[t] -> H[t]
    M.addRate('Q', 'H', hospitalization, resultTransfer=('hospitalization', 'Disease Progression'))  # Q[t] -> H[t]
    M.addRate('Iq', 'H', hospitalization, resultTransfer=(('cases', 'Disease Progression'),('hospitalization', 'Disease Progression')))  # Iq[t] -> H[t]

    # cured (detected):
    M.newState(name='CR', axesInit={"District": 0, "Age": 0, "Gender": 0})
    M.addRate('H', 'CR', 1.0, queueSrc="Disease Progression")  # H[t] -> CR[t]  this is a dequeueing operation and thus the rate needs to be one!
    M.addRate('Q', 'CR', 1.0, queueSrc="Disease Progression")  # H[t] -> R[t]  this is a dequeueing operation and thus the rate needs to be one!
    # ---- intensive care:
    # in intensive care
    M.newState(name='HIC', axesInit={"Disease Progression": 0, "District": 0, "Age": 0, "Gender": 0})
    # dead
    M.newState(name='D', axesInit={"District": 0, "Age": 0, "Gender": 0})
    M.addRate('H', 'HIC', hic)
    M.addRate('HIC', 'H', 1.0, queueSrc="Disease Progression")  # HIC[t] -> H[t] If intensive care was survived, start over in hospital
    # rate to die from intensive care:
    rd = M.newVariables({'rd': rdInit}, forcePos=False)  # rate to die during ICU
    M.addRate('HIC', 'D', rd, resultTransfer=('deaths', 'Disease Progression'))

    # cumulative total detected (= measured) cases:
    DPAx = - M.findAxis('Disease Progression').curAxis
    # M.addResult('cumul_cases', lambda State: tf.reduce_sum(State['H'], DPAx, keepdims=True) + tf.reduce_sum(State['Q'], DPAx, keepdims=True) +
    #                                          tf.reduce_sum(State['HIC'], DPAx, keepdims=True) + State['CR'] + State['D'])  # ('I', 'S')
    # M.addResult('cumul_dead', lambda State: State['D'])  # ('I', 'S')

    if False:
        plt.figure('hospitalization')
        toPlot = np.squeeze(hospitalization())
        if toPlot.ndim > 1:
            plt.imshow(toPlot)
        else:
            plt.plot(toPlot)

    return M

def plotTotalCases(AllMeasured):
    plt.figure("Neuinfektionen")
    # plt.plot((np.sum(RawCumulCases[1:, :, :, :], (1, 2, 3)) - np.sum(RawCumulCases[0:-1, :, :, :], (1, 2, 3))) / np.sum(RawPopM + RawPopW) * 100000)
    factor = 1.0
    if False:
        factor = 100000.0 / np.sum(AllMeasured['Population'])
        plt.ylabel("Cases / 100.000 und Tag")
    else:
        plt.ylabel("Cases")
    plt.plot(factor * np.sum(AllMeasured['Cases'][1:, :, :, :], (1, 2, 3)))
    plt.plot(factor * np.sum(10.0 * AllMeasured['Dead'][1:, :, :], (1, 2, 3)))
    if "Hospitalized" in AllMeasured.keys():
        plt.plot(factor * np.sum(AllMeasured['Hospitalized'][1:, :, :, :], (1, 2, 3)))
        plt.legend(('New Infections', 'Deaths (*10)', 'Hospitalized'))
    else:
        plt.legend(('New Infections', 'Deaths (*10)'))
    plt.xlabel("Tag")
    offsetDay = 0  # being sunday
    plt.xticks(range(offsetDay, len(AllMeasured['Dates']), 7), [date for date in AllMeasured['Dates'][offsetDay:-1:7]], rotation="vertical")
    # plt.xlim(45, len(Dates))
    plt.tight_layout()
    plt.hlines(0.25, 0, len(AllMeasured['Dead']), linestyles="dashed")
    # plt.vlines(11*7, 0, 5, linestyles="dashed")
